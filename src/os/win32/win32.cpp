// Copyright (c) 2025 Seong Woo Lee. All rights reserved.
#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#define UNICODE
#define _UNICODE
#include <windows.h>

#pragma comment(lib, "kernel32")
#pragma comment(lib, "user32")
#pragma comment(lib, "gdi32")

function LRESULT CALLBACK
win32_service_window_proc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    LRESULT result = {};

    switch (msg) 
    {
        case WM_CREATE_DANGEROUS_WINDOW: {
            Win32_Create_Window_Param *param = (Win32_Create_Window_Param *)wparam;
            result = (LRESULT)CreateWindowExW(0, win32.wcex.lpszClassName, param->title,
                                              WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                                              CW_USEDEFAULT, CW_USEDEFAULT, param->width, param->height, 
                                              0, 0, win32.hinst, 0);
        } break;

        case WM_DESTROY_DANGEROUS_WINDOW: {
            DestroyWindow((HWND)wparam);
        } break;

        default: {
            result = DefWindowProcW(hwnd, msg, wparam, lparam);
        } break;
    }

    return result;
}
    
// @Note: User window.
function LRESULT CALLBACK
win32_window_proc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    LRESULT result = {};

    switch(msg) 
    {
        case WM_CLOSE: {
            Os_Window *window_to_close = NULL;
            dll_for(os.window_sentinel, it)
            {
                if (it->handle.u64 == (U64)hwnd)
                {
                    it->should_close = true;
                    window_to_close = it;
                    break;
                }
            }
            assert(window_to_close);
            PostThreadMessageW(win32.main_thread_id, msg, (WPARAM)window_to_close, lparam);
        } break;

        case WM_CHAR:
        case WM_KEYDOWN:
        case WM_QUIT:
        case WM_SIZE: {
            PostThreadMessageW(win32.main_thread_id, msg, wparam, lparam);
        } break;

        default: {
            result = DefWindowProcW(hwnd, msg, wparam, lparam);
        } break;
    }

    return result;
}

function DWORD WINAPI
win32_gui_main_thread_entry(void *param)
{
    win32.wcex.cbSize             = sizeof(win32.wcex);
    win32.wcex.style              = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
    win32.wcex.lpfnWndProc        = win32_window_proc;
    win32.wcex.cbClsExtra         = 0;
    win32.wcex.cbWndExtra         = 0;
    win32.wcex.hInstance          = GetModuleHandleW(0);
    win32.wcex.hIcon              = LoadIcon(NULL, IDI_APPLICATION);
    win32.wcex.hCursor            = LoadCursor(NULL, IDC_ARROW);
    win32.wcex.hbrBackground      = (HBRUSH)GetStockObject(BLACK_BRUSH);
    win32.wcex.lpszMenuName       = NULL;
    win32.wcex.lpszClassName      = L"WindowClass";
    assume(RegisterClassExW(&win32.wcex));

    thread_main_entry(0);

    ExitProcess(0);
}

#if 0
function void
OS_POLL_EVENTS(win32_poll_events)
{
    MSG msg;
    HWND handle;
    _GLFWwindow* window;

    while (PeekMessageW(&msg, NULL, 0, 0, PM_REMOVE))
    {
        if (msg.message == WM_QUIT)
        {
            // NOTE: While GLFW does not itself post WM_QUIT, other processes
            //       may post it to this one, for example Task Manager
            // HACK: Treat WM_QUIT as a close on all windows

            window = _glfw.windowListHead;
            while (window)
            {
                _glfwInputWindowCloseRequest(window);
                window = window->next;
            }
        }
        else
        {
            TranslateMessage(&msg);
            DispatchMessageW(&msg);
        }
    }

    // HACK: Release modifier keys that the system did not emit KEYUP for
    // NOTE: Shift keys on Windows tend to "stick" when both are pressed as
    //       no key up message is generated by the first key release
    // NOTE: Windows key is not reported as released by the Win+V hotkey
    //       Other Win hotkeys are handled implicitly by _glfwInputWindowFocus
    //       because they change the input focus
    // NOTE: The other half of this is in the WM_*KEY* handler in windowProc
    handle = GetActiveWindow();
    if (handle)
    {
        window = GetPropW(handle, L"GLFW");
        if (window)
        {
            int i;
            const int keys[4][2] =
            {
                { VK_LSHIFT, GLFW_KEY_LEFT_SHIFT },
                { VK_RSHIFT, GLFW_KEY_RIGHT_SHIFT },
                { VK_LWIN, GLFW_KEY_LEFT_SUPER },
                { VK_RWIN, GLFW_KEY_RIGHT_SUPER }
            };

            for (i = 0;  i < 4;  i++)
            {
                const int vk = keys[i][0];
                const int key = keys[i][1];
                const int scancode = _glfw.win32.scancodes[key];

                if ((GetKeyState(vk) & 0x8000))
                    continue;
                if (window->keys[key] != GLFW_PRESS)
                    continue;

                _glfwInputKey(window, key, scancode, GLFW_RELEASE, getKeyMods());
            }
        }
    }

    window = _glfw.win32.disabledCursorWindow;
    if (window)
    {
        int width, height;
        _glfwGetWindowSizeWin32(window, &width, &height);

        // NOTE: Re-center the cursor only if it has moved since the last call,
        //       to avoid breaking glfwWaitEvents with WM_MOUSEMOVE
        // The re-center is required in order to prevent the mouse cursor stopping at the edges of the screen.
        if (window->win32.lastCursorPosX != width / 2 ||
            window->win32.lastCursorPosY != height / 2)
        {
            _glfwSetCursorPosWin32(window, width / 2, height / 2);
        }
    }
}
#endif

function
OS_CREATE_WINDOW(win32_create_window)
{
    Os_Window *result = NULL;

    // @Note: Place this before creating window.
    assume(SUCCEEDED(SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2)));
    
    HINSTANCE hinst = win32.hinst;
    assert(hinst);

    Win32_Create_Window_Param param = {};
    {
        param.title  = title;
        param.width  = width;
        param.height = height;
    }

    HWND window = (HWND)SendMessageW(win32.service_window, WM_CREATE_DANGEROUS_WINDOW, (WPARAM)&param, 0);

    result = arena_push_struct(win32.arena, Os_Window);
    dll_append(os.window_sentinel, result);

    result->handle.u64 = (U64)window;
    result->should_close = false;

    return result;
}

function HWND
win32_get_hwnd(Os_Window *window)
{
    HWND result = (HWND)window->handle.u64;
    return result;
}

function
OS_CLOSE_WINDOW(win32_close_window)
{
    HWND hwnd = win32_get_hwnd(window);
    SendMessage(win32.service_window, WM_DESTROY_DANGEROUS_WINDOW, (WPARAM)hwnd, 0);

    B32 found = false;

    dll_for(os.window_sentinel, it)
    {
        if (it->handle.u64 == window->handle.u64)
        {
            found = true;
            // @Todo: Fragmentation
            it->prev->next = it->next;
            it->next->prev = it->prev;
            break;
        }
    }

    assert(found);
}

function
OS_GET_DPI(win32_get_dpi)
{
    HWND hwnd = (HWND)window->handle.u64;
    U32 result = GetDpiForWindow(hwnd);
    return result;
}

function
OS_GET_CLIENT_SIZE(win32_get_client_size)
{
    V2U result = {};
    HWND hwnd = win32_get_hwnd(window);
    RECT rect = {};
    GetClientRect(hwnd, &rect);
    result.x = rect.right - rect.left;
    result.y = rect.bottom - rect.top;
    return result;
}

function DWORD WINAPI
win32_thread_proc(void *param)
{
    Win32_Thread *thread = (Win32_Thread *)param;
    thread->proc(thread->param);
    return 0;
}

function
OS_CREATE_THREAD(win32_create_thread)
{
    U64 result = 0;

    DWORD thread_id;

    Win32_Thread *thread = arena_push_struct(win32.arena, Win32_Thread);
    thread->proc   = proc;
    thread->param  = param;
    thread->handle = CreateThread(0, 0, win32_thread_proc, thread, 0, &thread_id);
    CloseHandle(thread->handle);

    result = thread_id;

    return result;
}

function
OS_JOIN_THREAD(win32_join_thread)
{
    HANDLE hthread = (HANDLE)thread.u64;
    if (hthread)
    {
        WaitForSingleObject(hthread, INFINITE);
        CloseHandle(hthread);
    }
}

function
OS_GUI_MESSAGE(win32_gui_message)
{
    UINT message_box_type = MB_ICONSTOP;
    MessageBoxExW(NULL, message, caption, message_box_type, 0);
}

function
OS_GET_PAGE_SIZE(win32_get_page_size)
{
    SYSTEM_INFO info;
    GetSystemInfo(&info);
    return info.dwPageSize;
}

function
OS_GET_LOGICAL_PROCESSOR_COUNT(win32_get_logical_processor_count)
{
    SYSTEM_INFO info;
    GetSystemInfo(&info);
    U32 result = info.dwNumberOfProcessors;
    return result;
}

function
OS_ABORT(win32_abort)
{
    ExitProcess(1);
}

function
OS_RESERVE(win32_reserve)
{
    DWORD alloc_flags   = MEM_RESERVE;
    DWORD protect_flags = PAGE_NOACCESS;
    if (commit)
    {
        alloc_flags   |= MEM_COMMIT;
        protect_flags = PAGE_READWRITE;
    }

    void *result = VirtualAlloc(0, size, alloc_flags, protect_flags);
    return result;
}

function
OS_RELEASE(win32_release)
{
    VirtualFree(ptr, 0, MEM_RELEASE);
}

function
OS_COMMIT(win32_commit)
{
    U64 page_snapped_size = size;
    page_snapped_size += win32_get_page_size() - 1;
    page_snapped_size -= page_snapped_size % win32_get_page_size();
    VirtualAlloc(ptr, page_snapped_size, MEM_COMMIT, PAGE_READWRITE);
}

function
OS_DECOMMIT(win32_decommit)
{
    VirtualFree(ptr, size, MEM_DECOMMIT);
}

function
OS_OPEN_FILE(win32_open_file)
{
    Temporary_Arena scratch = scratch_begin();

    Utf16 path16 = utf16_from_utf8(scratch.arena, path);

    DWORD desired_access = 0;
    if (flags & OS_FILE_ACCESS_READ)  
    { desired_access |= GENERIC_READ; }

    if (flags & OS_FILE_ACCESS_WRITE) 
    { desired_access |= GENERIC_WRITE; }

    DWORD share_mode = 0;
    if (flags & OS_FILE_ACCESS_SHARED) 
    { share_mode = FILE_SHARE_READ; }

    SECURITY_ATTRIBUTES security_attr = {};
    {
        security_attr.nLength              = sizeof(SECURITY_ATTRIBUTES);
        security_attr.lpSecurityDescriptor = NULL;
        security_attr.bInheritHandle       = FALSE;
    };

    DWORD creation_disposition = 0;
    if (flags & OS_FILE_ACCESS_CREATE_NEW)
    { creation_disposition = CREATE_ALWAYS; }
    else
    { creation_disposition = OPEN_EXISTING; }

    DWORD flags_and_attributes = 0;
    HANDLE template_file = NULL;

    HANDLE file = CreateFileW((LPCWSTR)path16.str, desired_access, share_mode, &security_attr,
                              creation_disposition, flags_and_attributes, template_file);

    if (file == INVALID_HANDLE_VALUE)
    { assert(0); }

    Os_Handle handle = {};
    handle.u64 = (U64)file;

    scratch_end(scratch);
    return handle;
}

function
OS_CLOSE_FILE(win32_close_file)
{
    HANDLE handle = (HANDLE)file.u64;
    if (handle != INVALID_HANDLE_VALUE)
    { CloseHandle(handle); }
}

function
OS_GET_FILE_SIZE(win32_get_file_size)
{
    HANDLE handle = (HANDLE)file.u64;
    if (handle == INVALID_HANDLE_VALUE)
    { assert(0); } // TODO: Error-Handling.
    LARGE_INTEGER file_size;
    GetFileSizeEx(handle, &file_size);
    U64 result = file_size.QuadPart;
    return result;
}

function
OS_READ_FILE(win32_read_file)
{
    HANDLE handle = (HANDLE)file.u64;

    if (handle == INVALID_HANDLE_VALUE)
    { assert(0); }

    LARGE_INTEGER zero_offset = {};
    if (SetFilePointerEx(handle, zero_offset, NULL, FILE_BEGIN) == 0)
    { assert(0); }

    Utf8 result = {};
    {
        result.str = arena_push_array(arena, U8, size);
        result.count = size;
    }

    if (size > U32_MAX)
    { assert(0); }

    if (!ReadFile(handle, result.str, (DWORD)size, (DWORD *)&result.count, NULL))
    { assert(0); }

    return result;
}

function
OS_READ_TIMER(win32_read_timer)
{
    LARGE_INTEGER counter;
    QueryPerformanceCounter(&counter);
    U64 result = counter.QuadPart;
    return result;
}

function
OS_QUERY_TIMER_FREQUENCY(win32_query_timer_frequency)
{
    LARGE_INTEGER frequency;
    QueryPerformanceFrequency(&frequency);
    U64 result = frequency.QuadPart;
    return result;
}

function void
win32_init(HINSTANCE hinst)
{
    os_create_window                  = win32_create_window;
    os_close_window                   = win32_close_window;
    os_get_dpi                        = win32_get_dpi;
    os_get_client_size                = win32_get_client_size;
    os_create_thread                  = win32_create_thread;
    os_join_thread                    = win32_join_thread;
    os_get_page_size                  = win32_get_page_size;
    os_get_logical_processor_count    = win32_get_logical_processor_count;
    os_gui_message                    = win32_gui_message;
    os_abort                          = win32_abort;
    os_reserve                        = win32_reserve;
    os_release                        = win32_release;
    os_commit                         = win32_commit;
    os_decommit                       = win32_decommit;
    os_open_file                      = win32_open_file;
    os_close_file                     = win32_close_file;
    os_get_file_size                  = win32_get_file_size;
    os_read_file                      = win32_read_file;
    os_read_timer                     = win32_read_timer;
    os_query_timer_frequency          = win32_query_timer_frequency;

    win32.arena = arena_alloc();
    win32.hinst = hinst;

    os.window_sentinel = arena_push_struct(win32.arena, Os_Window);
    os.window_sentinel->prev = os.window_sentinel;
    os.window_sentinel->next = os.window_sentinel;
}
